package cz.pasekj.pia.fiveinarow.data.entity;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import cz.pasekj.pia.fiveinarow.game.PlayerColor;
import org.springframework.data.redis.core.RedisHash;

import java.io.Serializable;

/**
 * Data entity representing a game state
 * This data entity is stored in a Redis database
 */
@RedisHash("Game")
public class GameEntity implements Serializable {
    /** identifier of the GameEntity record -> it is supposed to be autogenerated UUID*/
    private String id;
    /** Email of the white player */
    private String whitePlayer;
    /** Email of the black player */
    private String blackPlayer;
    /** Flag indicating whether a player has already won */
    private boolean isWin;
    /** Color of a player who's on move */
    private PlayerColor onMove;
    /** String representation of the game board -> Redis had problems storing PlayerColor[][] */
    private String board;
    /** Count of empty board places */
    private int emptyCnt;

    /**
     * Constructor - used by the framework for loading the state from DB
     */
    public GameEntity() {}

    /**
     * Constructor
     * @param id unique identifier of the game board
     * @param whitePlayer email of the white player
     * @param blackPlayer email of the black player
     * @param board string representation of the game board
     */
    public GameEntity(String id, String whitePlayer, String blackPlayer, String board) {
        this.id = id;
        this.whitePlayer = whitePlayer;
        this.blackPlayer = blackPlayer;
        this.onMove = PlayerColor.WHITE;
        this.isWin = false;
        this.board = board;

        PlayerColor[][] boardTmp = getBoard();
        int width = boardTmp.length;
        int height = boardTmp[0].length;
        this.emptyCnt = width*height;
    }

    /**
     * Get ID of the game
     * @return ID of the game
     */
    public String getId() {
        return id;
    }

    /**
     * Get email of the white player
     * @return white player email
     */
    public String getWhitePlayer() {
        return whitePlayer;
    }

    /**
     * Get email of the black player
     * @return black player email
     */
    public String getBlackPlayer() {
        return blackPlayer;
    }

    /**
     * Get color of a player who's on move
     * @return PlayerColor of the one who's on move
     */
    public PlayerColor getOnMove() {
        return onMove;
    }

    /**
     * Get player who won the game
     * @return color of the player who won or null if no one has already win
     */
    public PlayerColor getWin() {
        if(!isWin) return null;
        return onMove;
    }

    /**
     * Set game as surrendered
     * @param winner color of the winner
     */
    public void setSurrendered(PlayerColor winner) {
        this.onMove = winner;
        this.isWin = true;
    }

    /**
     * Get game board
     * @return 2D array of PlayerColor
     */
    public PlayerColor[][] getBoard() {
        ObjectMapper objectMapper = new ObjectMapper();
        try {
            return objectMapper.readValue(board, PlayerColor[][].class);
        } catch (JsonProcessingException e) {
            return null;
        }
    }

    /**
     * Set game board
     * @param gameBoard String representation of the 2D PlayerColor array
     */
    public void setBoard(PlayerColor[][] gameBoard) {
        ObjectMapper objectMapper = new ObjectMapper();
        try {
            this.board = objectMapper.writeValueAsString(gameBoard);
        } catch (JsonProcessingException e) {
            e.printStackTrace();
        }
    }

    /**
     * Perform a move
     * @param player email of the player who has performed the move
     * @param x x coordinate of the new piece
     * @param y y coordinate of te new piece
     * @return bool flag indicating whether the move has been performed
     */
    public boolean performMove(String player, int x, int y) {
        // if someone has already win, do nothing
        if (isWin) return false;

        // get the game board
        PlayerColor[][] gameBoard = getBoard();
        if(gameBoard == null) return false;
        int width = gameBoard.length;
        int height = gameBoard[0].length;

        // get color of the player
        PlayerColor playerColor;
        if(player.equals(whitePlayer)) playerColor = PlayerColor.WHITE;
        else playerColor = PlayerColor.BLACK;

        // check if the move is valid
        if (playerColor != onMove) return false;
        if (x < 0 || x >= width || y < 0 || y >= height) return false;
        if(gameBoard[x][y] != PlayerColor.EMPTY) return false;

        // perform the move and check win
        gameBoard[x][y] = onMove;
        isWin = checkWin(x, y, playerColor, gameBoard);

        // check if there are some places left on the board
        // if the board is full - current player is the winner
        this.emptyCnt--;
        if(this.emptyCnt <= 0) {
            isWin = true;
        }

        // change the player on move
        // in case there's win, the onMove var must represents the winner
        if(!isWin) {
            onMove = onMove == PlayerColor.WHITE ? PlayerColor.BLACK : PlayerColor.WHITE;
        }

        // store changed game board
        setBoard(gameBoard);
        return true;
    }

    /**
     * Check if current move led to a win
     * @param x x coordinate of the move
     * @param y y coordinate of the move
     * @param playerColor color of the player who performed the move
     * @param gameBoard game board
     * @return bool flag indicating win
     */
    private boolean checkWin(int x, int y, PlayerColor playerColor, PlayerColor[][] gameBoard) {
        return checkLines(x, y, playerColor, gameBoard) || checkDiagonals(x, y, playerColor, gameBoard);
    }

    /**
     * Check if current move led to a win - LINES
     * @param x x coordinate of the move
     * @param y y coordinate of the move
     * @param playerColor color of the player who performed the move
     * @param gameBoard game board
     * @return bool flag indicating win
     */
    private boolean checkLines(int x, int y, PlayerColor playerColor, PlayerColor[][] gameBoard) {
        int width = gameBoard.length;
        int height = gameBoard[0].length;
        int cntr = 0;
        // Check horizontal
        for (int ix = 0; ix < width; ix++) {
            if (gameBoard[ix][y] == playerColor) {
                cntr++;
                if(cntr >= 5) return true;
            }
            else cntr = 0;
        }

        // Check vertical
        cntr = 0;
        for (int iy = 0; iy < height; iy++) {
            if(gameBoard[x][iy] == playerColor) {
                cntr++;
                if(cntr >= 5) return true;
            }
            else cntr = 0;
        }

        return false;
    }

    /**
     * Check if current move led to a win - DIAGONALS
     * @param x x coordinate of the move
     * @param y y coordinate of the move
     * @param playerColor color of the player who performed the move
     * @param gameBoard game board
     * @return bool flag indicating win
     */
    private boolean checkDiagonals(int x, int y, PlayerColor playerColor, PlayerColor[][] gameBoard) {
        int width = gameBoard.length;
        int height = gameBoard[0].length;
        // Check diagonal
        int dx;
        int dy;
        if(x >= y) {
            dx = x - y;
            dy = 0;
        } else {
            dx = 0;
            dy = y - x;
        }

        int cntr = 0;
        while (dx < width && dy < height) {
            if(gameBoard[dx][dy] == playerColor) {
                cntr++;
                if (cntr >= 5) return true;
            }
            else cntr = 0;
            dx++;
            dy++;
        }

        // Check inverse diagonal
        int ix;
        int iy;
        if(x + y < width) {
            ix = x + y;
            iy = 0;
        } else {
            ix = width - 1;
            iy = (x + y) - ix;
        }

        cntr = 0;
        while (ix >= 0 && iy < height) {
            if(gameBoard[ix][iy] == playerColor) {
                cntr++;
                if(cntr >= 5) return true;
            }
            else cntr = 0;

            ix--;
            iy++;
        }

        return false;
    }

}
